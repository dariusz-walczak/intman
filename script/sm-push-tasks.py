#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Command line script pushing task list into jira"""

# Standard library imports
import sys

# Project imports
import cjm.cfg
import cjm.data
import cjm.issue
import cjm.project
import cjm.run
import cjm.schema
import cjm.sprint


def parse_options(args):
    """Parse command line options"""
    defaults = cjm.cfg.load_defaults()
    parser = cjm.cfg.make_common_parser(defaults)

    parser.add_argument(
        "tasks_file", action="store",
        help=(
            "Path to the json task definition list as generated by the {0:s} script and described"
            " by the {1:s} schema"
            "".format(cjm.SM_CREATE_TASKS_FILE, cjm.schema.make_subpath("tasks.json"))))

    default_project_id = defaults.get("project", {}).get("id")
    default_project_key = defaults.get("project", {}).get("key")

    project_group = parser.add_mutually_exclusive_group()
    project_group.add_argument(
        "--project-id", action="store", metavar="ID", dest="project_id",
        default=default_project_id,
        help=(
            "ID of the project to create tasks for{0:s}"
            "".format(cjm.cfg.fmt_dft(default_project_id))))
    project_group.add_argument(
        "--project-key", action="store", metavar="KEY", dest="project_key",
        default=default_project_key,
        help=(
            "KEY identifying the project to create tasks for{0:s}"
            "".format(cjm.cfg.fmt_dft(default_project_key))))

    parser.add_argument(
        "--dry-run", action="store_true", dest="dry_run",
        help="Print what's going to happen, only. Do not push commitment comments to jira")

    return parser.parse_args(args)


def _process_issue_types(cfg, issues):
    issue_types = cjm.issue.request_issue_types(cfg)
    issue_type_names = [i["name"] for i in issue_types]
    duplicate_issue_types = set([i for i in issue_type_names if issue_type_names.count(i) > 1])

    if duplicate_issue_types:
        sys.stderr.write(
            "WARNING: Found duplicate issue type names ({0:s})\n"
            "".format(", ".join(duplicate_issue_types)))

    issue_type_lut = dict((t["name"], t) for t in issue_types)

    for task in issues:
        type_raw = task.get("type name", "Task")

        try:
            task["type id"] = issue_type_lut[type_raw]["id"]
        except KeyError:
            sys.stderr.write("ERROR: Unrecognized issue type ({0:s})\n".format(type_raw))
            raise cjm.codes.CjmError(cjm.codes.INPUT_DATA_ERROR)

    return issues


def _process_project_id(issues, project_id):
    for task in issues:
        task["project id"] = project_id
    return issues


def _determine_project_id(cfg):
    project_id = cfg["project"]["id"]
    project_key = cfg["project"]["key"]

    if project_id is None and project_key is None:
        sys.stderr.write(
            "ERROR: The project must be identified either by id or by key and using the defaults"
            " file or command line arguments\n")
        raise cjm.codes.CjmError(cjm.codes.CONFIGURATION_ERROR)

    if project_id is None:
        project = cjm.project.request_project_by_key(cfg, cfg["project"]["key"])
        return project["id"]
    return project_id


def _verify_relation_links(cfg, issues):
    issue_by_local_id = dict((i["idx"], i) for i in issues)

    for issue in issues:
        related = issue.get("links", {}).get("related", [])

        for outward_raw in related:
            if isinstance(outward_raw, str):
                if cjm.issue.request_issue(cfg, outward_raw) is None:
                    sys.stderr.write("ERROR: Issue ({0:s}) doesn't exist\n".format(outward_raw))
                    raise cjm.codes.CjmError(cjm.codes.INPUT_DATA_ERROR)
            elif isinstance(outward_raw, int) and outward_raw not in issue_by_local_id:
                sys.stderr.write("ERROR: Undefined local issue id ({0:d})\n".format(outward_raw))
                raise cjm.codes.CjmError(cjm.codes.INPUT_DATA_ERROR)


def _extract_links(issues):
    issue_by_local_id = dict((i["idx"], i) for i in issues)
    unique_related_links = set()

    for issue in issues:
        related_issues = issue.get("links", {}).get("related", [])

        for outward_raw in related_issues:
            if isinstance(outward_raw, str):
                outward_key = outward_raw
            else:
                outward_key = issue_by_local_id[outward_raw]["actual"]["key"]
            if issue["actual"]["key"] is None or outward_key is None:
                import pdb; pdb.set_trace()
            unique_related_links.add(tuple(sorted([issue["actual"]["key"], outward_key])))

    return [{"inward": i[0], "outward": i[1], "type": "Relates"} for i in unique_related_links]


def _make_tracking_id(tasks_data, issue):
    return "{0:s}/{1:04d}".format(tasks_data["set id"], issue["idx"])


def _request_issue_by_tracking_id(cfg, tracking_id):
    found_issues = cjm.sprint.request_issues_by_comment(cfg, tracking_id)

    if not found_issues:
        return None
    elif len(found_issues) > 1:
        sys.stderr.write(
            "ERROR: Multiple issues ({0:s}) found for given tracking id ({1:s})\n"
            "".format(", ".join([i["key"] for i in found_issues]), tracking_id))
        raise cjm.codes.CjmError(cjm.codes.JIRA_DATA_ERROR)
    else:
        return found_issues[0]


def _create_issues(cfg, tasks_data, issues):
    for issue in issues:
        if issue["actual"] is None:
            new_issue = cjm.issue.request_issue_create(cfg, issue)
            issue["actual"] = new_issue
            issue["key"] = new_issue["key"]
            issue["has_tracking_comment"] = False
            sys.stdout.write("Created issue: {0:s}\n".format(issue["key"]))

        if not issue["has_tracking_comment"]:
            comment_json = cjm.issue.make_comment_body(_make_tracking_id(tasks_data, issue))
            cjm.issue.request_comment_create(cfg, issue["key"], comment_json)
            sys.stdout.write("Created tracking comment for issue {0:s}\n".format(issue["key"]))


def _process_jira_state(cfg, tasks_data, issues):
    for issue in issues:
        tracking_id = _make_tracking_id(tasks_data, issue)
        tracked_issue = _request_issue_by_tracking_id(cfg, tracking_id)
        key = issue.get("key")
        if key is not None:
            issue["actual"] = cjm.issue.request_issue(cfg, key)
        else:
            issue["actual"] = tracked_issue
            issue["key"] = issue["actual"]["key"] if issue["actual"] is not None else None
        issue["has_tracking_comment"] = tracked_issue is not None


def main(options):
    """Entry function"""
    cfg = cjm.cfg.apply_options(cjm.cfg.init_defaults(), options)
    cfg["project"]["id"] = options.project_id
    cfg["project"]["key"] = options.project_key

    # Load sprint data:

    tasks_data = cjm.data.load(cfg, options.tasks_file, "tasks.json")

    _verify_relation_links(cfg, tasks_data["tasks"])

    _process_jira_state(cfg, tasks_data, tasks_data["tasks"])
    issues = _process_issue_types(cfg, tasks_data["tasks"])
    _process_project_id(issues, _determine_project_id(cfg))

    if options.dry_run:
        print("Dry run TODO")
        return cjm.codes.NO_ERROR

    _create_issues(cfg, tasks_data, issues)

    related_links = _extract_links(issues)

    #link_types = set(t["name"] for t in cjm.issue.request_issue_link_types(cfg)) # Use it to verify

    for link in related_links:
        cjm.issue.request_issue_link_create(cfg, link["inward"], link["outward"], link["type"])
        sys.stdout.write(
            "Created link of type '{0:s}' between issues {1:s} and {2:s}\n"
            "".format(link["type"], link["inward"], link["outward"]))

    return cjm.codes.NO_ERROR


if __name__ == '__main__':
    cjm.run.run(main, parse_options(sys.argv[1:]))
